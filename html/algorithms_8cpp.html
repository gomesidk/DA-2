<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA_2: algorithms.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DA_2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">algorithms.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &quot;<a class="el" href="algorithms_8h_source.html">algorithms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dataset_8h_source.html">dataset.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for algorithms.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="algorithms_8cpp__incl.png" border="0" usemap="#aalgorithms_8cpp" alt=""/></div>
<map name="aalgorithms_8cpp" id="aalgorithms_8cpp">
<area shape="rect" title=" " alt="" coords="166,5,285,32"/>
<area shape="rect" title=" " alt="" coords="154,155,217,181"/>
<area shape="rect" title=" " alt="" coords="26,80,111,107"/>
<area shape="rect" title=" " alt="" coords="135,80,215,107"/>
<area shape="rect" title=" " alt="" coords="240,80,316,107"/>
<area shape="rect" href="algorithms_8h.html" title=" " alt="" coords="340,80,444,107"/>
<area shape="rect" href="dataset_8h.html" title=" " alt="" coords="395,155,478,181"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a004b29898d20f752511139ccba1e7e1e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a004b29898d20f752511139ccba1e7e1e">knapsackBF</a> (unsigned int values[], unsigned int weights[], unsigned int n, unsigned int maxWeight, bool usedItems[])</td></tr>
<tr class="memdesc:a004b29898d20f752511139ccba1e7e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brute-force solution for the 0/1 Knapsack problem.  <a href="algorithms_8cpp.html#a004b29898d20f752511139ccba1e7e1e">More...</a><br /></td></tr>
<tr class="separator:a004b29898d20f752511139ccba1e7e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e92c0f311e8d0ec67798db20e8dfe"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a7d1e92c0f311e8d0ec67798db20e8dfe">knapsackDP</a> (unsigned int values[], unsigned int weights[], unsigned int n, unsigned int maxWeight, bool usedItems[])</td></tr>
<tr class="memdesc:a7d1e92c0f311e8d0ec67798db20e8dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic programming solution for the 0/1 Knapsack problem using static arrays.  <a href="algorithms_8cpp.html#a7d1e92c0f311e8d0ec67798db20e8dfe">More...</a><br /></td></tr>
<tr class="separator:a7d1e92c0f311e8d0ec67798db20e8dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6220f6c51f5b583ecf6ac7ccbf35da74"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a6220f6c51f5b583ecf6ac7ccbf35da74">knapsackDP1</a> (unsigned int values[], unsigned int weights[], unsigned int n, unsigned int maxWeight, bool usedItems[])</td></tr>
<tr class="memdesc:a6220f6c51f5b583ecf6ac7ccbf35da74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic programming solution using vectors instead of static arrays.  <a href="algorithms_8cpp.html#a6220f6c51f5b583ecf6ac7ccbf35da74">More...</a><br /></td></tr>
<tr class="separator:a6220f6c51f5b583ecf6ac7ccbf35da74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679488b88be9f691026a49cdbb17c79a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#a679488b88be9f691026a49cdbb17c79a">compare</a> (const <a class="el" href="structPallet.html">Pallet</a> &amp;a, const <a class="el" href="structPallet.html">Pallet</a> &amp;b)</td></tr>
<tr class="memdesc:a679488b88be9f691026a49cdbb17c79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for sorting <a class="el" href="structPallet.html" title="Represents a pallet with an ID, weight, and profit value.">Pallet</a> items by profit-to-weight ratio.  <a href="algorithms_8cpp.html#a679488b88be9f691026a49cdbb17c79a">More...</a><br /></td></tr>
<tr class="separator:a679488b88be9f691026a49cdbb17c79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d4d96db433323aeadead2efb7b0aa1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#af8d4d96db433323aeadead2efb7b0aa1">knapsackGreedy</a> (vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt; pallets, unsigned int n, unsigned int maxWeight, bool usedItems[])</td></tr>
<tr class="memdesc:af8d4d96db433323aeadead2efb7b0aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedy approximation algorithm for the knapsack problem.  <a href="algorithms_8cpp.html#af8d4d96db433323aeadead2efb7b0aa1">More...</a><br /></td></tr>
<tr class="separator:af8d4d96db433323aeadead2efb7b0aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb95fba6517618523b964678c58c2191"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="algorithms_8cpp.html#aeb95fba6517618523b964678c58c2191">knapsackILP</a> (unsigned int values[], unsigned int weights[], unsigned int n, unsigned int maxWeight, bool usedItems[])</td></tr>
<tr class="memdesc:aeb95fba6517618523b964678c58c2191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branch-and-bound (ILP) solution to the 0/1 knapsack problem.  <a href="algorithms_8cpp.html#aeb95fba6517618523b964678c58c2191">More...</a><br /></td></tr>
<tr class="separator:aeb95fba6517618523b964678c58c2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a679488b88be9f691026a49cdbb17c79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679488b88be9f691026a49cdbb17c79a">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPallet.html">Pallet</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPallet.html">Pallet</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparator for sorting <a class="el" href="structPallet.html" title="Represents a pallet with an ID, weight, and profit value.">Pallet</a> items by profit-to-weight ratio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First pallet </td></tr>
    <tr><td class="paramname">b</td><td>Second pallet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a has a better ratio than b </dd></dl>

</div>
</div>
<a id="a004b29898d20f752511139ccba1e7e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004b29898d20f752511139ccba1e7e1e">&#9670;&nbsp;</a></span>knapsackBF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int knapsackBF </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>weights</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usedItems</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brute-force solution for the 0/1 Knapsack problem. </p>
<p>This function tries all combinations of items to find the one with the maximum value without exceeding the maximum weight. In the case of equal values, it prefers the one with fewer items; if still equal, it prefers the one with a lower sum of indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Array containing the values of the items. </td></tr>
    <tr><td class="paramname">weights</td><td>Array containing the weights of the items. </td></tr>
    <tr><td class="paramname">n</td><td>Total number of items. </td></tr>
    <tr><td class="paramname">maxWeight</td><td>The maximum total weight the knapsack can carry. </td></tr>
    <tr><td class="paramname">usedItems</td><td>Output array indicating which items are selected in the optimal solution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum total value for the given constraints. </dd></dl>

</div>
</div>
<a id="a7d1e92c0f311e8d0ec67798db20e8dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1e92c0f311e8d0ec67798db20e8dfe">&#9670;&nbsp;</a></span>knapsackDP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int knapsackDP </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>weights</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usedItems</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic programming solution for the 0/1 Knapsack problem using static arrays. </p>
<p>Dynamic programming solution with static arrays for the knapsack problem.</p>
<p>Constructs a DP table of size [n][maxWeight+1] and backtracks to find which items were selected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Array of item values. </td></tr>
    <tr><td class="paramname">weights</td><td>Array of item weights. </td></tr>
    <tr><td class="paramname">n</td><td>Number of items. </td></tr>
    <tr><td class="paramname">maxWeight</td><td>Maximum allowable total weight. </td></tr>
    <tr><td class="paramname">usedItems</td><td>Output array indicating selected items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum value that can be obtained. </dd></dl>

</div>
</div>
<a id="a6220f6c51f5b583ecf6ac7ccbf35da74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6220f6c51f5b583ecf6ac7ccbf35da74">&#9670;&nbsp;</a></span>knapsackDP1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int knapsackDP1 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>weights</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usedItems</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic programming solution using vectors instead of static arrays. </p>
<p>Dynamic programming solution using std::vector for the knapsack problem.</p>
<p>Functionally similar to knapsackDP but uses std::vector for flexibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Array of item values. </td></tr>
    <tr><td class="paramname">weights</td><td>Array of item weights. </td></tr>
    <tr><td class="paramname">n</td><td>Number of items. </td></tr>
    <tr><td class="paramname">maxWeight</td><td>Maximum allowable total weight. </td></tr>
    <tr><td class="paramname">usedItems</td><td>Output array indicating selected items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum value that can be obtained. </dd></dl>

</div>
</div>
<a id="af8d4d96db433323aeadead2efb7b0aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d4d96db433323aeadead2efb7b0aa1">&#9670;&nbsp;</a></span>knapsackGreedy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int knapsackGreedy </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structPallet.html">Pallet</a> &gt;&#160;</td>
          <td class="paramname"><em>pallets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usedItems</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greedy approximation algorithm for the knapsack problem. </p>
<p>Greedy heuristic solution for the knapsack problem based on profit-to-weight ratio.</p>
<p>Selects items by highest value-to-weight ratio until capacity is full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pallets</td><td>Vector of <a class="el" href="structPallet.html" title="Represents a pallet with an ID, weight, and profit value.">Pallet</a> items. </td></tr>
    <tr><td class="paramname">n</td><td>Number of items. </td></tr>
    <tr><td class="paramname">maxWeight</td><td>Maximum allowed weight. </td></tr>
    <tr><td class="paramname">usedItems</td><td>Output array indicating selected items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total profit achieved by the greedy algorithm. </dd></dl>

</div>
</div>
<a id="aeb95fba6517618523b964678c58c2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb95fba6517618523b964678c58c2191">&#9670;&nbsp;</a></span>knapsackILP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int knapsackILP </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>weights</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usedItems</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Branch-and-bound (ILP) solution to the 0/1 knapsack problem. </p>
<p>Branch-and-bound (ILP) solution for the knapsack problem.</p>
<p>Prunes branches of the solution tree that cannot yield better results using upper-bound estimates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Array of item values. </td></tr>
    <tr><td class="paramname">weights</td><td>Array of item weights. </td></tr>
    <tr><td class="paramname">n</td><td>Number of items. </td></tr>
    <tr><td class="paramname">maxWeight</td><td>Maximum allowable weight. </td></tr>
    <tr><td class="paramname">usedItems</td><td>Output array marking selected items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimal value found using branch-and-bound. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
